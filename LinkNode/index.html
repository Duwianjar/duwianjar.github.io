<?php $title = "Center Node Multi-Window (Overlap Aware)"; ?>
<!doctype html>
<html lang="id">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>
        <?= htmlspecialchars($title) ?>
    </title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            overflow: hidden;
            background:
                radial-gradient(1200px 700px at 20% 15%, rgba(60, 120, 255, .18), transparent 55%),
                radial-gradient(900px 600px at 80% 70%, rgba(0, 255, 255, .10), transparent 60%),
                radial-gradient(900px 600px at 30% 80%, rgba(167, 139, 250, .10), transparent 60%),
                #070b12;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
        }

        .hud {
            position: fixed;
            left: 14px;
            top: 14px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            color: rgba(255, 255, 255, .72);
            font-size: 12px;
            user-select: none;
            pointer-events: none;
            z-index: 10;
        }

        .pill {
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, .18);
            background: rgba(2, 6, 23, .35);
            backdrop-filter: blur(6px);
            box-shadow: 0 12px 50px rgba(0, 0, 0, .35);
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <div class="hud">
        <div class="pill">Node kamu selalu center</div>
        <div class="pill">Jika window lain overlap → node-nya muncul di window ini</div>
        <div class="pill">Jika tidak overlap → beam ke arah window tsb (mentok tepi)</div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');

            // ====== HiDPI ======
            function resize() {
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                canvas.width = Math.floor(innerWidth * dpr);
                canvas.height = Math.floor(innerHeight * dpr);
                canvas.style.width = innerWidth + 'px';
                canvas.style.height = innerHeight + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            addEventListener('resize', resize, {
                passive: true
            });
            resize();

            // ====== ID per window/tab ======
            const tabId = (crypto?.randomUUID) ? crypto.randomUUID() :
                ('tab_' + Math.random().toString(16).slice(2) + Date.now());

            // ====== BroadcastChannel ======
            const CH_NAME = "center_node_link_v3_overlap";
            const bc = ("BroadcastChannel" in window) ? new BroadcastChannel(CH_NAME) : null;

            // fallback localStorage
            const LS_KEY = "center_node_link_v3_overlap_msg";

            function post(msg) {
                if (bc) bc.postMessage(msg);
                else localStorage.setItem(LS_KEY, JSON.stringify({
                    ...msg,
                    _ts: Date.now()
                }));
            }
            if (!bc) {
                addEventListener('storage', (e) => {
                    if (e.key !== LS_KEY || !e.newValue) return;
                    try {
                        onMessage(JSON.parse(e.newValue));
                    } catch { }
                });
            } else {
                bc.onmessage = (e) => {
                    try {
                        onMessage(e.data);
                    } catch { }
                };
            }

            // ====== Utils ======
            const now = () => Date.now();
            const rand = (a, b) => a + Math.random() * (b - a);
            const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

            // ====== Presence + bounds ======
            const peers = new Map(); // id -> { last, sx, sy, ow, oh }
            const TTL = 3200;

            function myBounds() {
                return {
                    sx: window.screenX ?? 0,
                    sy: window.screenY ?? 0,
                    ow: window.outerWidth ?? innerWidth,
                    oh: window.outerHeight ?? innerHeight,
                };
            }

            // Estimasi origin konten (top-left viewport) dalam koordinat layar
            function myContentOriginScreen() {
                const b = myBounds();
                const chromeX = (b.ow - innerWidth) / 2;
                const chromeY = (b.oh - innerHeight);
                return {
                    x: b.sx + chromeX,
                    y: b.sy + chromeY
                };
            }

            function centerLocal() {
                return {
                    x: innerWidth / 2,
                    y: innerHeight / 2
                };
            }

            function centerScreenOf(bounds) {
                return {
                    x: bounds.sx + bounds.ow / 2,
                    y: bounds.sy + bounds.oh / 2
                };
            }

            function myCenterScreen() {
                return centerScreenOf(myBounds());
            }

            function cleanup() {
                const t = now();
                for (const [id, p] of peers.entries()) {
                    if (t - (p.last || 0) > TTL) peers.delete(id);
                }
            }

            function hello() {
                post({
                    type: "hello",
                    from: tabId
                });
                ping();
            }

            function ping() {
                post({
                    type: "ping",
                    from: tabId,
                    b: myBounds()
                });
            }

            function bye() {
                post({
                    type: "bye",
                    from: tabId
                });
            }

            function onMessage(msg) {
                if (!msg || msg.from === tabId) return;

                if (msg.type === "hello") {
                    if (msg.b) peers.set(msg.from, {
                        ...msg.b,
                        last: now()
                    });
                    else peers.set(msg.from, {
                        ...(peers.get(msg.from) || {}),
                        last: now()
                    });
                    ping();
                    return;
                }

                if (msg.type === "ping") {
                    if (!msg.b) return;
                    peers.set(msg.from, {
                        ...msg.b,
                        last: now()
                    });
                    return;
                }

                if (msg.type === "bye") {
                    peers.delete(msg.from);
                    return;
                }
            }

            // ====== Visual settings ======
            const NODE_R = 34;
            const PEER_R = 28;

            // Accent colors
            const C_CYAN = "0, 210, 255";
            const C_VIOLET = "167, 139, 250";
            const C_ORANGE = "249, 115, 22";

            // ====== Background subtle fog ======
            function drawFog(t) {
                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                const w = innerWidth,
                    h = innerHeight;

                const blobs = [{
                    x: w * 0.25 + Math.sin(t * 0.25) * 40,
                    y: h * 0.30 + Math.cos(t * 0.22) * 30,
                    r: 240,
                    c: `rgba(${C_CYAN},0.06)`
                },
                {
                    x: w * 0.70 + Math.cos(t * 0.18) * 45,
                    y: h * 0.35 + Math.sin(t * 0.20) * 30,
                    r: 280,
                    c: `rgba(${C_VIOLET},0.05)`
                },
                {
                    x: w * 0.55 + Math.sin(t * 0.16) * 35,
                    y: h * 0.78 + Math.cos(t * 0.14) * 25,
                    r: 260,
                    c: `rgba(${C_ORANGE},0.035)`
                },
                ];

                for (const b of blobs) {
                    const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
                    g.addColorStop(0, b.c);
                    g.addColorStop(1, "rgba(0,0,0,0)");
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // ====== Node drawing ======
            function drawNode(cx, cy, r, isMe) {
                const g1 = ctx.createRadialGradient(cx, cy, r * 0.15, cx, cy, r * 3.2);
                g1.addColorStop(0, isMe ? "rgba(255,255,255,0.22)" : `rgba(${C_VIOLET},0.12)`);
                g1.addColorStop(0.35, `rgba(${C_CYAN},0.22)`);
                g1.addColorStop(0.65, `rgba(${C_VIOLET},0.10)`);
                g1.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = g1;
                ctx.beginPath();
                ctx.arc(cx, cy, r * 3.2, 0, Math.PI * 2);
                ctx.fill();

                const g2 = ctx.createRadialGradient(cx - r * 0.22, cy - r * 0.22, r * 0.08, cx, cy, r);
                g2.addColorStop(0, "rgba(255,255,255,0.98)");
                g2.addColorStop(0.55, "rgba(170,245,255,0.94)");
                g2.addColorStop(0.78, `rgba(${C_CYAN},0.92)`);
                g2.addColorStop(1, "rgba(80,160,255,0.88)");
                ctx.fillStyle = g2;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                ctx.save();
                ctx.globalAlpha = 0.35;
                ctx.beginPath();
                ctx.arc(cx - r * 0.25, cy - r * 0.28, r * 0.26, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255,255,255,0.9)";
                ctx.fill();
                ctx.restore();
            }

            // ============================================================
            // ====== NEW LIGHTNING: BIG + ADAPTIVE + TAPER + NO END DOT ===
            // ============================================================
            function lightningPath(ax, ay, bx, by, t, jag = 1.0) {
                const dx = bx - ax,
                    dy = by - ay;
                const dist = Math.hypot(dx, dy);
                const segs = Math.max(18, Math.floor(dist / 16));
                const nx = -dy / (dist || 1);
                const ny = dx / (dist || 1);

                ctx.beginPath();
                for (let i = 0; i <= segs; i++) {
                    const p = i / segs;
                    const x = ax + dx * p;
                    const y = ay + dy * p;

                    const amp = (1 - Math.abs(2 * p - 1)) * (12 + 10 * Math.sin(t * 0.9)) * jag;
                    const n1 = Math.sin((p * 10 + t * 2.3) * 2.2);
                    const n2 = Math.sin((p * 21 + t * 3.1));
                    const off = (n1 + 0.65 * n2) * amp * 0.18;

                    const jx = x + nx * off;
                    const jy = y + ny * off;

                    if (i === 0) ctx.moveTo(jx, jy);
                    else ctx.lineTo(jx, jy);
                }
            }

            // closer = thicker; far = thinner
            function widthByDistance(dist) {
                const near = 220;
                const far = 950;
                const t = Math.max(0, Math.min(1, (dist - near) / (far - near)));
                return (1 - t) * 11.2 + t * 3.9; // big -> small
            }

            function strokeGlowTapered(ax, ay, bx, by, baseWidth) {
                const grad = ctx.createLinearGradient(ax, ay, bx, by);
                // near node bright
                grad.addColorStop(0.00, "rgba(235,255,255,0.98)");
                grad.addColorStop(0.08, "rgba(170,245,255,0.92)");
                grad.addColorStop(0.20, `rgba(${C_CYAN},0.80)`);
                // far: more transparent
                grad.addColorStop(0.70, `rgba(${C_CYAN},0.38)`);
                grad.addColorStop(1.00, `rgba(${C_CYAN},0.18)`);

                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                // outer bloom
                ctx.strokeStyle = `rgba(${C_CYAN},0.10)`;
                ctx.lineWidth = baseWidth * 3.2;
                ctx.stroke();

                // secondary bloom
                ctx.strokeStyle = `rgba(${C_VIOLET},0.07)`;
                ctx.lineWidth = baseWidth * 2.25;
                ctx.stroke();

                // main glow
                ctx.strokeStyle = `rgba(${C_CYAN},0.34)`;
                ctx.lineWidth = baseWidth * 1.35;
                ctx.stroke();

                // colored inner (gives taper vibe)
                ctx.strokeStyle = grad;
                ctx.lineWidth = baseWidth * 0.88;
                ctx.stroke();

                // sharp core
                ctx.strokeStyle = "rgba(235,255,255,0.98)";
                ctx.lineWidth = Math.max(1.2, baseWidth * 0.28);
                ctx.stroke();
            }

            function drawLightning(ax, ay, bx, by, t) {
                const dx = bx - ax,
                    dy = by - ay;
                const dist = Math.hypot(dx, dy);

                const baseWidth = widthByDistance(dist);

                // main
                lightningPath(ax, ay, bx, by, t, 1.0);
                strokeGlowTapered(ax, ay, bx, by, baseWidth);

                // branches only near node (biar ujung edge bersih)
                const branchCount = dist < 700 ? 2 : 1;
                for (let k = 0; k < branchCount; k++) {
                    const p = 0.16 + Math.random() * 0.32; // dekat node
                    const sx = ax + dx * p;
                    const sy = ay + dy * p;

                    const ang = Math.atan2(dy, dx) + (Math.random() * 1.2 - 0.6);
                    const len = 60 + Math.random() * 110;
                    const ex = sx + Math.cos(ang) * len;
                    const ey = sy + Math.sin(ang) * len;

                    ctx.save();
                    ctx.globalAlpha = 0.60;

                    lightningPath(sx, sy, ex, ey, t + k * 1.7, 0.75);

                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";

                    ctx.strokeStyle = `rgba(${C_CYAN},0.22)`;
                    ctx.lineWidth = baseWidth * 0.62;
                    ctx.stroke();

                    ctx.strokeStyle = "rgba(235,255,255,0.80)";
                    ctx.lineWidth = Math.max(1.0, baseWidth * 0.18);
                    ctx.stroke();

                    ctx.restore();
                }

                // sparks only near node
                if (Math.random() < 0.18) {
                    const p = 0.05 + Math.random() * 0.25;
                    const sx = ax + dx * p,
                        sy = ay + dy * p;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1.4 + Math.random() * 2.4, 0, Math.PI * 2);
                    ctx.fillStyle = "rgba(235,255,255,0.9)";
                    ctx.fill();
                }
            }

            // Ray to edge within this canvas (MENTOK TEPI)
            function pointOnEdgeFromAngle(cx, cy, angle) {
                const ux = Math.cos(angle),
                    uy = Math.sin(angle);

                const pad = 0; // <= 0 biar benar-benar mentok tepi
                const left = pad,
                    right = innerWidth - pad;
                const top = pad,
                    bottom = innerHeight - pad;

                let tMax = Infinity;
                if (ux > 0) tMax = Math.min(tMax, (right - cx) / ux);
                if (ux < 0) tMax = Math.min(tMax, (left - cx) / ux);
                if (uy > 0) tMax = Math.min(tMax, (bottom - cy) / uy);
                if (uy < 0) tMax = Math.min(tMax, (top - cy) / uy);

                return {
                    x: cx + ux * tMax,
                    y: cy + uy * tMax
                };
            }

            // ====== Particles around my node ======
            const particles = Array.from({
                length: 34
            }, () => ({
                a: rand(0, Math.PI * 2),
                r: rand(50, 120),
                s: rand(0.002, 0.006),
                z: rand(0.6, 1.0),
            }));

            function drawParticles(cx, cy, t) {
                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                for (const p of particles) {
                    p.a += p.s * 60 * 0.016;
                    const rr = p.r + Math.sin(t * 0.9 + p.a * 2.0) * 6;
                    const x = cx + Math.cos(p.a) * rr;
                    const y = cy + Math.sin(p.a) * rr;

                    const rad = 1.2 * p.z;
                    ctx.beginPath();
                    ctx.arc(x, y, rad, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(235,255,255,${0.15 * p.z})`;
                    ctx.fill();
                }
                ctx.restore();
            }

            // ====== Decide: show peer node inside OR beam to edge ======
            function peerCenterToLocal(peerBounds) {
                const pc = centerScreenOf(peerBounds);
                const origin = myContentOriginScreen();
                return {
                    x: pc.x - origin.x,
                    y: pc.y - origin.y
                };
            }

            function isInsideViewport(pt, margin = 0) {
                return (
                    pt.x >= -margin &&
                    pt.y >= -margin &&
                    pt.x <= innerWidth + margin &&
                    pt.y <= innerHeight + margin
                );
            }

            // glow halus hanya untuk node peer yang benar-benar terlihat (overlap)
            function drawPeerLocalGlow(x, y) {
                const g = ctx.createRadialGradient(x, y, 1, x, y, 28);
                g.addColorStop(0, "rgba(235,255,255,0.80)");
                g.addColorStop(0.25, `rgba(${C_CYAN},0.22)`);
                g.addColorStop(0.6, `rgba(${C_VIOLET},0.12)`);
                g.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, 28, 0, Math.PI * 2);
                ctx.fill();
            }

            // ====== Render loop ======
            let t = 0;

            function tick() {
                t += 1 / 60;

                ctx.clearRect(0, 0, innerWidth, innerHeight);

                // vignette
                const vg = ctx.createRadialGradient(innerWidth / 2, innerHeight / 2, 0, innerWidth / 2, innerHeight / 2, Math.max(innerWidth, innerHeight));
                vg.addColorStop(0, "rgba(0,0,0,0)");
                vg.addColorStop(1, "rgba(0,0,0,0.40)");
                ctx.fillStyle = vg;
                ctx.fillRect(0, 0, innerWidth, innerHeight);

                drawFog(t);
                cleanup();

                const meLocal = centerLocal();
                const meScreen = myCenterScreen();

                for (const p of peers.values()) {
                    const peerLocal = peerCenterToLocal(p);

                    if (isInsideViewport(peerLocal, 0)) {
                        // tampilkan node peer di posisi itu
                        const px = clamp(peerLocal.x, 14, innerWidth - 14);
                        const py = clamp(peerLocal.y, 14, innerHeight - 14);

                        // lightning langsung ke node peer (distance adaptif => makin dekat makin tebal)
                        drawLightning(meLocal.x, meLocal.y, px, py, t + 0.7);

                        // peer node muncul
                        drawNode(px, py, PEER_R, false);

                        // glow halus dekat peer (boleh, karena ini bukan "ujung pinggir")
                        ctx.save();
                        ctx.globalAlpha = 0.85;
                        drawPeerLocalGlow(px, py);
                        ctx.restore();

                    } else {
                        // beam ke arah peer -> mentok tepi canvas
                        const pc = centerScreenOf(p);
                        const angle = Math.atan2(pc.y - meScreen.y, pc.x - meScreen.x);
                        const edge = pointOnEdgeFromAngle(meLocal.x, meLocal.y, angle);

                        // TANPA bulatan di ujung edge (biar terasa nyambung)
                        drawLightning(meLocal.x, meLocal.y, edge.x, edge.y, t);
                    }
                }

                // node kita (selalu center)
                drawParticles(meLocal.x, meLocal.y, t);
                drawNode(meLocal.x, meLocal.y, NODE_R, true);

                requestAnimationFrame(tick);
            }

            // ====== Start presence ======
            hello();
            const hb = setInterval(ping, 450);
            addEventListener('beforeunload', () => {
                clearInterval(hb);
                bye();
                try {
                    if (bc) bc.close();
                } catch { }
            });

            tick();
        })();
    </script>
</body>

</html>